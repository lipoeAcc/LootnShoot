local rendercam = require "rendercam.rendercam"

local input_left = hash("left")
local input_right = hash("right")
local input_up = hash("up")
local input_down = hash("down")

local input_primary_hit = hash("primary_hit")

local trigger_response = hash("trigger_response")
local portal_group = hash("portal")
local damage = hash("damage")
local heal = hash("heal")

local player_stat_init = hash("player_stat_init")



local function fire_rocket(self)
	-- fire in the direction of the mouse
	local dir = vmath.normalize(self.mouse - go.get_position())
	local angle = math.atan2(dir.y, dir.x)
	local rot = vmath.quat_rotation_z(angle)
	dir.z = 0
	local props = { dir = dir }
	factory.create("#rocketfactory", nil, rot, props)
	self.rocket_disabled = true
	timer.delay(self.rocket_reload_time, false, function() self.rocket_disabled = false end)
	msg.post(msg.url("/gui/ammo"), "rocket_reload", { reload_time = self.rocket_reload_time })
end

local function set_current_health(self, health)
	self.current_health = health
	msg.post("/gui/health_ui", "set_current_health", { current_health = self.current_health, max_health = self.max_health })
end

local function update_sword_stats(self, knockback, melee_attackspeed)
	msg.post(self.player_collection[2], "update_sword_stats", { knockback = knockback, melee_attackspeed = melee_attackspeed })
end

local function set_player_stats(self, max_health, speed, rocket_reload_time, knockback, melee_attackspeed)
	self.max_health = max_health
	self.speed = speed
	self.rocket_reload_time = rocket_reload_time
	self.knockback = knockback
	self.melee_attackspeed = melee_attackspeed

	update_sword_stats(self, knockback, melee_attackspeed)
	set_current_health(self, self.max_health)
end



function init(self)
	msg.post(".", "acquire_input_focus")

	msg.post(msg.url("main","/level_control","level_control"), "player_loaded")
	
	-- positional variables
	self.firing = false
	self.dir = vmath.vector3(0, 0, 0)
	self.input = vmath.vector3()
	self.mouse = vmath.vector3(0, 0, 0)

	--player_stats
	--self.max_health = 100
	--self.speed = 100
	--set_current_health(self, 20)
	--self.rocket_reload_time = 2
	--sword_stats
	--self.knockback = 100
	--self.melee_attackspeed = 2

	self.rocket_disabled = false
	self.player_collection = {go.get_id("/player1/player1"),go.get_id("/player1/sword")}

	-- A timer with a delay of zero will trigger just before the text frame's update.
	local myID = self.player_collection[1]
	timer.delay(0, false, function() rendercam.follow(myID) rendercam.set_ortho_scale(0.3) end)
	-- self.follow = true
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	if self.moving then
		local pos = go.get_position()
		pos = pos + self.dir * self.speed * dt

		for i, id in ipairs(self.player_collection) do
			--local pos = go.get_position(id)
			pos = pos + self.dir * self.speed * dt
			--set an offset for the sword into moving direction
			if(i == 2) then
				pos = pos + 15 * self.dir
				--set the rotation of the sword
				local angle = math.atan2(self.dir.y, self.dir.x)
				local rot = vmath.quat_rotation_z(angle)
				go.set_rotation(rot, id)
			end
			go.set_position(pos, id)
		end

		

	end

	if self.firing and not self.rocket_disabled then
		fire_rocket(self)
	end

	self.input.x = 0
	self.input.y = 0

	self.moving = false
	self.firing = false
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if message_id == trigger_response and message.group == portal_group and message.enter then
		-- disable portal to have time to spawn next level
		local portal_trigger_url = msg.url(nil, message.other_id, "portal_trigger")
		msg.post(portal_trigger_url, "disable")
		
		msg.post("/gui/messenger", "display_message", { message = "You have entered a portal! I wonder what will happen..." })
		-- message the loader to finish current level and load the next
		local level_control_url = msg.url("main","/level_control", "level_control")
		msg.post(level_control_url, "level_completed")
	elseif message_id == damage then
		set_current_health(self, self.current_health - message.damage)
		if self.current_health <= 0 then
			msg.post("/gui/messenger", "display_message", { message = "You died!" })
			local level_control_url = msg.url("main","/level_control", "level_control")
			msg.post(level_control_url, "player_died")
		end
	elseif message_id == heal then
		set_current_health(self, self.current_health + message.amount)
	elseif message_id == player_stat_init then
		set_player_stats(self, message.max_health, message.speed, message.rocket_reload_time, message.knockback, message.melee_attackspeed)
	end
end

function on_input(self, action_id, action)
	if action.x and action.y then
		-- convert mouse position from screen coordinates to world coordinates
		self.mouse = rendercam.screen_to_world_2d(action.x, action.y)
	end


	if action_id == input_left then
		self.input.x = -1
	elseif action_id == input_right then
		self.input.x = 1
	elseif action_id == input_up then
		self.input.y = 1
	elseif action_id == input_down then
		self.input.y = -1
	elseif action_id == input_primary_hit and action.pressed then
		self.firing = true
	end
	if vmath.length(self.input) > 0 then
		self.moving = true
		self.dir = vmath.normalize(self.input)
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
